# import standard modules
import logging
import sys
import json
import os
import argparse
import time
from dataclasses import dataclass, asdict
import threading
import requests
import signal

# import 3rd party modules

# import local modules
from gcp_utils.settings import (
    GOOGLE_CLOUD_PROJECT,
    GOOGLE_COMPUTE_REGION,
    GOOGLE_PUBSUB_TOPIC,
    logger
)
from gcp_utils import pubsub
import cloud_processor

# set the logging level to always be DEBUG in this module
logger.setLevel(logging.DEBUG)


def run_prediction_server():
    """
        Loop pulling messages until interrupted.
    """

    # Define your data and attributes.  These are optional and only used for filtering messages.
    attributes = {}
    sub_topic_id = GOOGLE_PUBSUB_TOPIC 
    pub_topic_id = GOOGLE_PUBSUB_TOPIC 

    logger.info(f"Creating a subscription for topic: {sub_topic_id}")
    subscription_id = pubsub.subscription(topic_id=sub_topic_id, subscription_id="prediction_server", **attributes)

    logger.debug(f'Created a subscription: {subscription_id}')

 
    # loop until receiving a signal to exit.
    try:
        while True:
            # Pull the message
            logging.debug(f"Pull messages: on {pub_topic_id} using subscription {subscription_id}")
            messages = pubsub.pull(topic_id=sub_topic_id, subscription_id=subscription_id, 
            max_messages=1,  # only handle one message at time.  Let other servers process messages.  Can increase if PubSub latency too high.
            leave_unacked=true, # only ACK once a message has been successfully processed. 
            timeout=60  # wait this long for a message
            )

            # Serially process all the messages received, there will be no messages if it times out.
            for message in messages:
                logger.info(f'Received message: {message.text} with attributes: {message.attributes}')

                # Event to signal when to stop extending the ack deadline
                stop_event = threading.Event()

                # Start a thread to keep extending the message's ack deadline to PubSub so it will not redistribute message to another server.
                ack_extension_period = 30  # seconds
                keep_alive_thread = threading.Thread(
                    target=extend_ack_deadline, 
                    args=(message, ack_extension_period, stop_event)
                )
                keep_alive_thread.start()

                # convert message.text to a dataclass
                data = cloud_processor.input_message(**json.loads(message.text))

                # process the message
                cloud_processor.process_message(data)

                # ack the message
                message.ack()  # only ack the message if successfully processed.
                stop_event.set()
                keep_alive_thread.join()
 
    except Exception as e:
        logger.exception(e)
    except KeyboardInterrupt:
        logger.info(f'keyboard interrupt received...exiting')
    finally:
        # Signal the keep-alive thread to stop and wait for it to finish
        stop_event.set()
        keep_alive_thread.join()

def extend_ack_deadline(message, ack_extension_period, stop_event):
    """
    Periodically extends the ack deadline of a message until stop_event is set.
    """
    while not stop_event.is_set():
        message.modify_ack_deadline(ack_extension_period)
        time.sleep(ack_extension_period / 2)

def check_preemption():
    """
    Checks the instance's metadata for a preemption notice.
    """
    METADATA_URL = "http://metadata.google.internal/computeMetadata/v1/instance/preempted"
    HEADERS = {"Metadata-Flavor": "Google"}

    try:
        response = requests.get(METADATA_URL, headers=HEADERS)
        if response.text == "TRUE":
            logging.info("Preemption notice received. Preparing to shutdown.")
            # Perform any cleanup or shutdown tasks here
            sys.exit(0)
    except requests.RequestException as e:
        logging.error(f"Error checking preemption status: {e}")

def signal_handler(signum, frame):
    """
    Handles interrupt signals to gracefully exit.
    """
    check_preemption()
    logging.info("Interrupt received. Exiting.")
 

# main function
if __name__ == "__main__":

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    run_prediction_server()

    # exit the program
    sys.exit(0)






    

